\documentclass{article}

\usepackage{amsmath, amssymb, amsthm}
\usepackage[margin=1in]{geometry}
\usepackage{tcolorbox}
\usepackage{fancyvrb}
\usepackage[hidelinks]{hyperref}
\usepackage{tikz, wasysym, tikz-cd}
\usepackage{mathtools} %xrightarrow
\usetikzlibrary{automata,arrows.meta,positioning,calc,decorations.pathmorphing}
\usepackage{etoolbox} % setcounter{counter}{num}
\usepackage{enumitem} % \begin{enumerate}[label=(\alph*)]
\usepackage{xcolor}

% QUIVER STUFF
% A TikZ style for curved arrows of a fixed height, due to Andr√©C.
\tikzset{curve/.style={settings={#1},to path={(\tikztostart)
    .. controls ($(\tikztostart)!\pv{pos}!(\tikztotarget)!\pv{height}!270:(\tikztotarget)$)
    and ($(\tikztostart)!1-\pv{pos}!(\tikztotarget)!\pv{height}!270:(\tikztotarget)$)
    .. (\tikztotarget)\tikztonodes}},
    settings/.code={\tikzset{quiver/.cd,#1}
        \def\pv##1{\pgfkeysvalueof{/tikz/quiver/##1}}},
    quiver/.cd,pos/.initial=0.35,height/.initial=0}
% TikZ arrowhead/tail styles.
\tikzset{tail reversed/.code={\pgfsetarrowsstart{tikzcd to}}}
\tikzset{2tail/.code={\pgfsetarrowsstart{Implies[reversed]}}}
\tikzset{2tail reversed/.code={\pgfsetarrowsstart{Implies}}}
% TikZ arrow styles.
\tikzset{no body/.style={/tikz/dash pattern=on 0 off 1mm}}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}
\numberwithin{theorem}{section}
\newtheorem{lemma}{Lemma}
%\numberwithin{lemma}{section}
\newtheorem{example}{Example}
\numberwithin{example}{section}

\theoremstyle{definition}
\newtheorem{definition}{Definition}
\numberwithin{definition}{section}
\newtheorem{problem}{Problem}
%\numberwithin{problem}{section}

\newenvironment{solution}
  {\renewcommand\qedsymbol{$\blacksquare$}\begin{proof}[Solution]}
  {\end{proof}}

\newtcolorbox{codebox}[1][] {
    colback = black!2!white,
    colframe = black,
    sharp corners,
    title = \texttt{#1}
}

\newtcolorbox{problembox} {
    colback = white,
    colframe = black,
    sharp corners
}

\newtcolorbox{defbox} {
    colback = blue!5!white,
    colframe = blue!75!black,
    sharp corners
}

\newtcolorbox{lemmabox} {
    colback = green!5!white,
    colframe = green!75!black,
    sharp corners
}

\newtcolorbox{theorembox} {
    colback = red!5!white,
    colframe = red!75!black,
    sharp corners
}

\newcommand{\Sup}{\text{Sup}}
\newcommand{\Inf}{\text{Inf}}
\DeclareMathOperator{\im}{im}
\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\cod}{cod}
\DeclareMathOperator{\id}{id}
\newcommand{\angles}[1]{\left<#1\right>}
\newcommand{\catname}[1]{{\normalfont\textbf{#1}}}
\newcommand{\GL}{\text{GL}}
\newcommand{\SL}{\text{SL}}
\newcommand{\sg}{\text{sg}}
\newcommand{\dd}{\mathop{}\!d}
\newcommand\defeq{\stackrel{\mathclap{\normalfont\mbox{\scriptsize def}}}{=}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \set, my favourite
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\DeclarePairedDelimiterX\set[1]\lbrace\rbrace{\def\given{\;\delimsize\vert\;}#1}
 
\newcommand{\naturalto}{%
  \mathrel{\vbox{\offinterlineskip
    \mathsurround=0pt
    \ialign{\hfil##\hfil\cr
      \normalfont\scalebox{1.2}{.}\cr
%      \noalign{\kern-.05ex}
      $\longrightarrow$\cr}
  }}%
}

% Actions to be done at the start of a new section, so just made a new macro
\newcommand{\Section}[1]{\section{#1} \setcounter{equation}{0}}

\setlength{\parindent}{0pt}

\title{Project 1 - 2023}
\author{Mitchell Holt (46977557)}

\begin{document}

\maketitle

\tableofcontents

\newpage

\section{GitHub Repository}

The entire source code for the project can be found on the
\href{https://github.com/mitchellholt/Mitchell-Holt-2504-2023-PROJECT1}
{\color{blue}GitHub repository}.


\section{Example Script}
The provided example script demonstrates some of the functionality of the
pre-existing code. The first few lines initialize the project, and then there is
an example of some basic polynomial arithmetic:

\begin{codebox}
    \begin{Verbatim}
x = x_poly(Polynomial)
p1 = 2x^3 + 4x^2 - 3x
p2 = 2x^4 - 4x^2 - 3x + 3

@show p1*p2
@show p1^3
    \end{Verbatim}
\end{codebox}

Output:
\begin{Verbatim}
    p1 * p2 = 4x^7 + 8x^6 - 14x^5 - 22x^4 + 6x^3 + 21x^2 - 9x
    p1 ^ 3 = 8x^9 + 48x^8 + 60x^7 - 80x^6 - 90x^5 + 108x^4 - 27x^3
\end{Verbatim}
We may also take the derivatives of polynomials:

\begin{codebox}
    \begin{Verbatim}
@show derivative(p1*p2)
@show derivative(p1)*p2 + p1*derivative(p2);
    \end{Verbatim}
\end{codebox}

Output:
\begin{Verbatim}
    derivative(p1 * p2) = 28x^6 + 48x^5 - 70x^4 - 88x^3 + 18x^2 + 42x - 9
    derivative(p1) * p2 + p1 * derivative(p2) = 28x^6 + 48x^5 - 70x^4 - 88x^3 + 18x^2 + 42x - 9
\end{Verbatim}

There are functions defined for working with polynomials modulo some prime,
which is particularly useful for factoring polynomials:

\begin{codebox}
    \begin{Verbatim}
prime = 17
p = mod((7x^3 + 2x^2 + 8x + 1)*(x^2+x+1),prime)
println("Will factor this polynomial (mod $prime): ", p)
factorization = factor(p,prime)
println("Here is the factorization: ", factorization)

pr = mod(expand_factorization(factorization),prime)
println("Reconstructing: ", pr)
    \end{Verbatim}
\end{codebox}

Output (with the third line split so the output will fit on the document):
\begin{Verbatim}
    Will factor this polynomial (mod 17): 7x^5 + 9x^4 + 11x^2 + 9x + 1
    Here is the factorization: Tuple{Polynomial, Int64}[(x + 8, 1),
        (x^2 + x + 1, 1), (x^2 + 2x + 7, 1), (7, 1)]
    Reconstructing: 7x^5 + 9x^4 + 11x^2 + 9x + 1
\end{Verbatim}

\bigbreak

\section{Tests}
The provided tests produce the following output:
\begin{Verbatim}
    test_euclid_ints - PASSED
    test_ext_euclid_ints - PASSED
    prod_test_poly - PASSED
    prod_derivative_test_poly - PASSED
    ext_euclid_test_poly - PASSED
    division_test_poly - PASSED

    doing prime = 5 	 ..........
    doing prime = 17 	..........
    doing prime = 19 	..........
    factor_test_poly - PASSED
\end{Verbatim}

\bigbreak

\section{Task 1}
\subsection{Example Script 2}
The new example script \texttt{example\_script\_2.jl} explores the main
functionality of the codebase: basic arithmetic on polynomials, the extended
Euclidean algorithm, Euclidean division, and factorization. Most notably,
because the division and factorization algorithms require us to work in
$\mathbb{Z}_p[x]$ for prime $p$, examples were given using different coefficient
fields:

\begin{codebox}[example\_script\_2.jl]
    \begin{Verbatim}[numbers=left,xleftmargin=5mm]
# division
println("\nDivision")
f1 = rand(PolynomialSparse; degree = 4, mean_degree = 2.0, max_coeff = 5)
f2 = rand(PolynomialSparse; degree = 3, mean_degree = 1.5, max_coeff = 5)
f3 = rand(PolynomialSparse; degree = 2, mean_degree = 1.0, max_coeff = 5)
g1, g2 = f1 * f2 + f3, f2
@show g1
@show g2
println("Euclidean division for g1 / g2:")
primes = [7, 11, 13, 17, 19, 23, 29]
for p in primes
    dividend, remainder = (divide(g1, g2))(p)
    println("\tin Z/$p[x]:\tg1 = ($dividend)($g2) + $remainder  (mod $p)")
end

# factorization
println("\nFactorization in Z/p[x]")
println("Let f = $f1 * $f2")
f = f1 * f2
@show f
for p in primes[3:end]
    factorization = factor(f, p)
    println("\tin Z/$p[x]:\tf = $factorization")
    println("\tReconstruction:\t$(mod(expand_factorization(factorization), p))")
end
    \end{Verbatim}
\end{codebox}

Output:
\begin{Verbatim}
    Division
    g1 = 10x^7 + 4x^6 + 15x^5 + 16x^4 + 12x^3 + 5x^2 + 14x + 8
    g2 = 2x^3 + 3x + 2
    Euclidean division for g1 / g2:
        in Z/7[x]:	g1 = (5x^4 + 2x^3 + 4)(2x^3 + 3x + 2) + 5x^2 + 2x  (mod 7)
        in Z/11[x]:	g1 = (5x^4 + 2x^3 + 4)(2x^3 + 3x + 2) + 5x^2 + 2x  (mod 11)
        in Z/13[x]:	g1 = (5x^4 + 2x^3 + 4)(2x^3 + 3x + 2) + 5x^2 + 2x  (mod 13)
        in Z/17[x]:	g1 = (5x^4 + 2x^3 + 4)(2x^3 + 3x + 2) + 5x^2 + 2x  (mod 17)
        in Z/19[x]:	g1 = (5x^4 + 2x^3 + 4)(2x^3 + 3x + 2) + 5x^2 + 2x  (mod 19)
        in Z/23[x]:	g1 = (5x^4 + 2x^3 + 4)(2x^3 + 3x + 2) + 5x^2 + 2x  (mod 23)
        in Z/29[x]:	g1 = (5x^4 + 2x^3 + 4)(2x^3 + 3x + 2) + 5x^2 + 2x  (mod 29)

    Factorization in Z/p[x]
    Let f = 5x^4 + 2x^3 + 4 * 2x^3 + 3x + 2
    f = 10x^7 + 4x^6 + 15x^5 + 16x^4 + 12x^3 + 12x + 8
        in Z/13[x]:	f = (x + 10)(x + 7)(x^2 + 3x + 4)(x^3 + 9x^2 + 2x + 12)(10)
        Reconstruction:	10x^7 + 4x^6 + 2x^5 + 3x^4 + 12x^3 + 12x + 8
        in Z/17[x]:	f = (x + 4)(x + 2)^^2(x + 6)(x^3 + 10x + 1)(10)
        Reconstruction:	10x^7 + 4x^6 + 15x^5 + 16x^4 + 12x^3 + 12x + 8
        in Z/19[x]:	f = (x + 11)(x + 13)(x^2 + 3x + 13)(x^3 + 11x + 1)(10)
        Reconstruction:	10x^7 + 4x^6 + 15x^5 + 16x^4 + 12x^3 + 12x + 8
        in Z/23[x]:	f = (x + 4)(x^2 + 19x + 6)(x^4 + 5x^3 + 10)(10)
        Reconstruction:	10x^7 + 4x^6 + 15x^5 + 16x^4 + 12x^3 + 12x + 8
        in Z/29[x]:	f = (x + 18)(x^2 + 11x + 21)(x^4 + 12x^3 + 24)(10)
        Reconstruction:	10x^7 + 4x^6 + 15x^5 + 16x^4 + 12x^3 + 12x + 8
\end{Verbatim}

\bigbreak

\subsection{Pretty Printing}
The show methods in both \texttt{polynomial.jl} and \texttt{term.jl} were
modified to meet the pretty printing rules. A global option was added to
determine if terms in polynomials were printed in ascending or descending term
order (defaulting to descending):

\begin{codebox}[polynomial.jl]
    \begin{Verbatim}[numbers=left,xleftmargin=5mm]
"""
Based global variable for deciding the order in which polynomial terms are
printed
"""
global lowest_to_highest :: Bool = false
    \end{Verbatim}
\end{codebox}

The provided \texttt{show} method for polynomials was replaced with the
following:

\begin{codebox}[polynomial.jl]
    \begin{Verbatim}[numbers=left,xleftmargin=5mm]
function show(io::IO, p::Polynomial) 
    if iszero(p)
        print(io,"0")
    else
        is_first = true
        n = length(p.terms)
        term_list = lowest_to_highest ? p.terms : reverse(p.terms)
        for t in term_list
            if iszero(t)
                continue
            elseif is_first
                print(io, t.coeff < 0 ? "-" : "", t)
            else
                print(io, t.coeff < 0 ? " - " : " + ", t)
            end
            is_first = false
        end
    end
end
    \end{Verbatim}
\end{codebox}

First, observe that the \texttt{lowest\_to\_highest} flag is used on line 7 to
determine in which order to iterate over the list of terms. If the given
polynomial is the zero polynomial, then the output is \texttt{0}. Otherwise, the
\texttt{show} method above will simply skip those terms which are zero.
Printing terms with negative coefficient as \texttt{1 - x} instead of
\texttt{1 + -x} was implemented by changing the monomial show method to always
display the absolute value of the coefficient. Then on line 14 above, the
\texttt{show} method prints either a \texttt{+} or \texttt{-} sign in front of
the monomial as appropriate. \medbreak

The final consideration is how to print the first term in the monomial so that
there is not ``\texttt{ + }" or ``\texttt{ - }" with excessive surrounding
whitespace at the start of the \texttt{show} output. It is not necessarily the
case that the first term in the list of terms for the polynomial will be
non-zero, so we introduce on line 5 a flag \texttt{is\_first}, which will be set
until the first non-zero term has been printed. Then at the first term we need
only check if it has positive coefficient (and print nothing before the term),
or negative (in which case we print ``\texttt{-}" with no surrounding
whitespace). \medbreak

Consider now the implementation of the \texttt{show} method for monomials:

\begin{codebox}[term.jl]
    \begin{Verbatim}[numbers=left,xleftmargin=5mm]
function show(io::IO, t::Term)
    if t.degree == 0
        print(io, abs(t.coeff))
    elseif abs(t.coeff) == 1
        print(io, "x", t.degree == 1 ? "" : int_to_superscript(t.degree))
    else
        print(io, abs(t.coeff), "x",
            t.degree == 1 ? "" : int_to_superscript(t.degree))
    end
end
    \end{Verbatim}
\end{codebox}

We check for zero degree terms (and print the coefficient only) on lines 2-3. At
line 4-5 we check if a polynomial has non-zero degree and has a coefficient of
$\pm 1$, in which case we print \texttt{x} instead of \texttt{1x}. Furthermore,
on lines 5 and 7-8, we only print the degree of the monomial if it not 1.
\medbreak

Finally, unicode superscript printing was implemented using a function
\texttt{int\_to\_superscript}:

\begin{codebox}[general\_alg.jl]
    \begin{Verbatim}[numbers=left,xleftmargin=5mm]
function digit_to_superscript(n :: Int) :: Char
    # Literal for zero
    zero_code = 0x2070
    
    # cringe edge cases
    if n == 1
        return Char(0x00B9)
    elseif n == 2
        return Char(0x00B2)
    elseif n == 3
        return Char(0x00B3)
    else
        # based normal case
        return Char(zero_code + n)
    end
end

function int_to_superscript(k :: Int) :: String
    k == 0 ? "" : int_to_superscript(div(k, 10)) * digit_to_superscript(mod(k, 10))
end
    \end{Verbatim}
\end{codebox}

The function \texttt{digit\_to\_superscript} converts a single digit to a
superscript unicode character and is called in the recursively defined
\texttt{int\_to\_superscript} on line 18. Notice that the \texttt{*} operator on
line 19 is the string concatenation operator. Although converting the input
\texttt{k} into a string and then mapping each character to a superscript one
would have worked, this method is much more efficient as no memory is allocated
for an intermediate string representation of the input.

\bigbreak

\section{Task 2}
\subsection{PolynomialSparse}
The \texttt{PolynomialSparse} only stores \emph{non-zero} terms and is defined
below. We will discuss the \texttt{DictLinkedList} data structure in detail in
section \ref{dll}. We will explore the definition of the
\texttt{PolynomialSparse} type and look at the non-trivial operations on it
which are substantially different to those on the provided type.

\begin{codebox}[polynomial\_sparse.jl]
    \begin{Verbatim}[numbers=left,xleftmargin=5mm]
struct PolynomialSparse

    # DictLinkedList mapping degrees of terms to the term. A polynomial is the
    # zero polynomial if and only if DictLinkedList is empty
    terms :: DictLinkedList{Int, Term}
    
    #Inner constructor of 0 polynomial
    PolynomialSparse() = new(DictLinkedList{Int, Term}(isless))

    #Inner constructor of polynomial based on arbitrary list of terms
    function PolynomialSparse(vt::Vector{Term})
        terms = DictLinkedList{Int, Term}(isless)
        for t in vt
            if iszero(t)
                continue
            elseif contains(terms, t.degree)
                replace!(terms, t.degree, t)
            else
                insert!(terms, t.degree, t)
            end
        end
        new(terms)
    end

    PolynomialSparse(dll :: DictLinkedList{Int, Term}) = new(dll)
end
    \end{Verbatim}
\end{codebox}

Notice in particular that, because we only store non-zero terms inside a sparse
polynomial, the unique way to represent the zero polynomial is the one where the
\texttt{terms} field is empty. Addition was implemented using heap-like
operations on \texttt{PolynomialSparse.terms} to take advantage of the
underlying list being sorted.

\begin{codebox}[basic\_polynomial\_operations/polynomial\_addition.jl]
    \begin{Verbatim}[numbers=left,xleftmargin=5mm]
function +(p1 :: PolynomialSparse, p2 :: PolynomialSparse) :: PolynomialSparse
    p1_ = deepcopy(p1)
    p2_ = deepcopy(p2)
    p = PolynomialSparse()
    while !iszero(p1_) || !iszero(p2_)
        if (degree(p1_) == degree(p2_))
            t = pop!(p1_) + pop!(p2_)
            iszero(t) ? continue : push!(p, t)
        elseif degree(p1_) > degree(p2_)
            push!(p, pop!(p1_))
        else
            push!(p, pop!(p2_))
        end
    end
    return p
end
    \end{Verbatim}
\end{codebox}

\bigbreak

\subsection{Tests}
The tests for sparse polynomials are identical to those for dense polynomials
and may be found in the file \texttt{test/polynomial\_sparse\_test.jl}.

\bigbreak

\subsection{DictLinkedList Data Structure} \label{dll}
The data structure \texttt{DictLinkedList\string{K, V\string}} is a sorted
linked list with values of type \texttt V along with a dictionary mapping some
key type \texttt K into the nodes of the linked list so that we can quickly
lookup values inside the linked list without having to traverse it. To make
the type polymorphic, we simply add a field in the struct containing a
comparator \texttt{comp}.

\begin{codebox}[dict\_linked\_list.jl]
    \begin{Verbatim}[numbers=left,xleftmargin=5mm]
mutable struct DictLinkedList{K, V}
    # Sorted linked list
    list :: MutableLinkedList{V}
    # Dictionary with with values pointing nodes in the linked list
    dict :: Dict{K, DataStructures.ListNode{V}}
    # total order on V
    comp :: Function

    DictLinkedList{K, V}(comp) where {K, V} = new(
        MutableLinkedList{V}(),
        Dict{K, DataStructures.ListNode{V}}(),
        comp)
end
    \end{Verbatim}
\end{codebox}

The \texttt{iteration} interface is implemented by simply iterating over the
underlying linked list (in order). Observe that on line 4 we compare pointers
for equality to improve speed without sacrificing correctness:

\begin{codebox}[dict\_linked\_list.jl]
    \begin{Verbatim}[numbers=left,xleftmargin=5mm]
function Base.iterate(
        dll :: DictLinkedList{K, V},
        state = dll.list.node) where {K, V}
    root_node = dll.list.node
    state.next === root_node ? nothing : (state.next.data, state.next)
end
    \end{Verbatim}
\end{codebox}

We may insert elements into the linked list
using \texttt{insert!}, which takes a key and value and inserts the value into
the underlying list (such that order is preserved) and maps the key to a pointer
to the newly created list node in the underlying dictionary.

\begin{codebox}[dict\_linked\_list.jl]
    \begin{Verbatim}[numbers=left,xleftmargin=5mm]
function insert!(dll :: DictLinkedList{K, V}, key :: K, value :: V) where {K, V}
    # check the key does not already exist in the dictionary
    haskey(dll.dict, key) && error("Duplicate key")

    # Pointer to the element immediately before where value should be inserted
    elem_before = dll.list.node
    if dll.comp(elem_before.prev.data, value)
        # can insert at the end of the list
        elem_before = elem_before.prev
    else
        next = iterate(dll)
        while next !== nothing
            (x, current) = next
            if dll.comp(x, value)
                elem_before = current
                next = iterate(dll, current)
            else
                break
            end
        end
    end
    # insert the value here
    new_node = DataStructures.ListNode{V}(value)
    new_node.prev = elem_before
    new_node.next = elem_before.next
    elem_before.next.prev = new_node
    elem_before.next = new_node
    dll.list.len += 1

    # add an entry to the dictionary
    dll.dict[key] = new_node
    return nothing
end
    \end{Verbatim}
\end{codebox}

There is also a method to remove a key from the dictionary and the value pointed
to by the key from the list:

\begin{codebox}[dict\_linked\_list.jl]
    \begin{Verbatim}[numbers=left,xleftmargin=5mm]
function remove!(dll :: DictLinkedList{K, V}, key :: K) :: Nothing where {K, V}
    !haskey(dll.dict, key) && error("Key does not exist")
    node = dll.dict[key]
    delete!(dll.dict, key)
    node.prev.next = node.next
    node.next.prev = node.prev
    dll.list.len -= 1
    return nothing
end
    \end{Verbatim}
\end{codebox}

Several other methods (including \texttt{filter!}, \texttt{lookup},
\texttt{map}, \texttt{replace!} and \texttt{show}) were implemented, none of
which are particularly exciting.

\bigbreak

\subsection{Discussion}

Having written the tests for sparse polynomials to be identical to those
provided for dense polynomials, we may easily compare the performance of each
data type using the \texttt{@time} macro. For the sake of conciseness, all
output except running time and memory used from \texttt{@time} has been manually
removed from the output:

\begin{Verbatim}
    ######################################
    # Dense polynomial tests #
    ######################################
    prod_test_poly - PASSED
     12.722033 seconds (allocations: 51.691 GiB)
    prod_derivative_test_poly - PASSED
      0.003085 seconds (allocations: 10.690 MiB)
    ext_euclid_test_poly - PASSED
      0.209129 seconds (allocations: 491.821 MiB)
    division_test_poly - PASSED
      0.830835 seconds (allocations: 2.168 GiB)

    doing prime = 5 	..........
    doing prime = 17 	..........
    doing prime = 19 	..........
    factor_test_poly - PASSED
      5.681664 seconds (allocations: 26.530 GiB)



    ######################################
    # Sparse polynomial tests #
    ######################################
    prod_test_poly_sparse - PASSED
     74.335241 seconds (allocations: 17.223 GiB)
    prod_derivative_test_poly_sparse - PASSED
      0.045319 seconds (allocations: 9.714 MiB)
    ext_euclid_test_poly_sparse - PASSED
      3.367378 seconds (allocations: 717.322 MiB)
    division_test_poly_sparse - PASSED
     10.505014 seconds (allocations: 2.087 GiB)

    doing prime = 5 	..........
    doing prime = 17 	..........
    doing prime = 19 	..........
    factor_test_poly_sparse - PASSED
     14.825052 seconds (allocations: 3.473 GiB)
\end{Verbatim}

Thus it is clear that, in every case, dense polynomial operations are faster
than those on sparse polynomials. However, for multiplication and factorization,
sparse polynomials use far less memory. Therefore we conclude that
multiplication and factorization are most efficient using the sparse
representations of polynomials.

\bigbreak

\section{Task 3}
\end{document}
