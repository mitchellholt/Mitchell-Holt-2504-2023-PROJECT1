\documentclass{article}

\usepackage{amsmath, amssymb, amsthm}
\usepackage[margin=1in]{geometry}
\usepackage{tcolorbox}
\usepackage{fancyvrb}
\usepackage[hidelinks]{hyperref}
\usepackage{tikz, wasysym, tikz-cd}
\usepackage{mathtools} %xrightarrow
\usetikzlibrary{automata,arrows.meta,positioning,calc,decorations.pathmorphing}
\usepackage{etoolbox} % setcounter{counter}{num}
\usepackage{enumitem} % \begin{enumerate}[label=(\alph*)]
\usepackage{xcolor}

% QUIVER STUFF
% A TikZ style for curved arrows of a fixed height, due to Andr√©C.
\tikzset{curve/.style={settings={#1},to path={(\tikztostart)
    .. controls ($(\tikztostart)!\pv{pos}!(\tikztotarget)!\pv{height}!270:(\tikztotarget)$)
    and ($(\tikztostart)!1-\pv{pos}!(\tikztotarget)!\pv{height}!270:(\tikztotarget)$)
    .. (\tikztotarget)\tikztonodes}},
    settings/.code={\tikzset{quiver/.cd,#1}
        \def\pv##1{\pgfkeysvalueof{/tikz/quiver/##1}}},
    quiver/.cd,pos/.initial=0.35,height/.initial=0}
% TikZ arrowhead/tail styles.
\tikzset{tail reversed/.code={\pgfsetarrowsstart{tikzcd to}}}
\tikzset{2tail/.code={\pgfsetarrowsstart{Implies[reversed]}}}
\tikzset{2tail reversed/.code={\pgfsetarrowsstart{Implies}}}
% TikZ arrow styles.
\tikzset{no body/.style={/tikz/dash pattern=on 0 off 1mm}}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}
\numberwithin{theorem}{section}
\newtheorem{lemma}{Lemma}
%\numberwithin{lemma}{section}
\newtheorem{example}{Example}
\numberwithin{example}{section}

\theoremstyle{definition}
\newtheorem{definition}{Definition}
\numberwithin{definition}{section}
\newtheorem{problem}{Problem}
%\numberwithin{problem}{section}

\newenvironment{solution}
  {\renewcommand\qedsymbol{$\blacksquare$}\begin{proof}[Solution]}
  {\end{proof}}

\newtcolorbox{codebox}[1][] {
    colback = black!2!white,
    colframe = black,
    sharp corners,
    title = \texttt{#1}
}

\newtcolorbox{problembox} {
    colback = white,
    colframe = black,
    sharp corners
}

\newtcolorbox{defbox} {
    colback = blue!5!white,
    colframe = blue!75!black,
    sharp corners
}

\newtcolorbox{lemmabox} {
    colback = green!5!white,
    colframe = green!75!black,
    sharp corners
}

\newtcolorbox{theorembox} {
    colback = red!5!white,
    colframe = red!75!black,
    sharp corners
}

\newcommand{\Sup}{\text{Sup}}
\newcommand{\Inf}{\text{Inf}}
\DeclareMathOperator{\im}{im}
\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\cod}{cod}
\DeclareMathOperator{\id}{id}
\newcommand{\angles}[1]{\left<#1\right>}
\newcommand{\catname}[1]{{\normalfont\textbf{#1}}}
\newcommand{\GL}{\text{GL}}
\newcommand{\SL}{\text{SL}}
\newcommand{\sg}{\text{sg}}
\newcommand{\dd}{\mathop{}\!d}
\newcommand\defeq{\stackrel{\mathclap{\normalfont\mbox{\scriptsize def}}}{=}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \set, my favourite
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\DeclarePairedDelimiterX\set[1]\lbrace\rbrace{\def\given{\;\delimsize\vert\;}#1}
 
\newcommand{\naturalto}{%
  \mathrel{\vbox{\offinterlineskip
    \mathsurround=0pt
    \ialign{\hfil##\hfil\cr
      \normalfont\scalebox{1.2}{.}\cr
%      \noalign{\kern-.05ex}
      $\longrightarrow$\cr}
  }}%
}

% Actions to be done at the start of a new section, so just made a new macro
\newcommand{\Section}[1]{\section{#1} \setcounter{equation}{0}}

\setlength{\parindent}{0pt}

\title{Project 1 - 2023}
\author{Mitchell Holt (46977557)}

\begin{document}

\maketitle

\tableofcontents

\newpage

\section{GitHub Repository}

The entire source code for the project can be found on the
\href{https://github.com/mitchellholt/Mitchell-Holt-2504-2023-PROJECT1}
{\color{blue}GitHub repository}.


\section{Example Script}
The provided example script demonstrates some of the functionality of the
pre-existing code. The first few lines initialize the project, and then there is
an example of some basic polynomial arithmetic:

\begin{codebox}
    \begin{Verbatim}
x = x_poly(Polynomial)
p1 = 2x^3 + 4x^2 - 3x
p2 = 2x^4 - 4x^2 - 3x + 3

@show p1*p2
@show p1^3
    \end{Verbatim}
\end{codebox}

Output:
\begin{Verbatim}
    p1 * p2 = 4x^7 + 8x^6 - 14x^5 - 22x^4 + 6x^3 + 21x^2 - 9x
    p1 ^ 3 = 8x^9 + 48x^8 + 60x^7 - 80x^6 - 90x^5 + 108x^4 - 27x^3
\end{Verbatim}
We may also take the derivatives of polynomials:

\begin{codebox}
    \begin{Verbatim}
@show derivative(p1*p2)
@show derivative(p1)*p2 + p1*derivative(p2);
    \end{Verbatim}
\end{codebox}

Output:
\begin{Verbatim}
    derivative(p1 * p2) = 28x^6 + 48x^5 - 70x^4 - 88x^3 + 18x^2 + 42x - 9
    derivative(p1) * p2 + p1 * derivative(p2) = 28x^6 + 48x^5 - 70x^4 - 88x^3 + 18x^2 + 42x - 9
\end{Verbatim}

There are functions defined for working with polynomials modulo some prime,
which is particularly useful for factoring polynomials:

\begin{codebox}
    \begin{Verbatim}
prime = 17
p = mod((7x^3 + 2x^2 + 8x + 1)*(x^2+x+1),prime)
println("Will factor this polynomial (mod $prime): ", p)
factorization = factor(p,prime)
println("Here is the factorization: ", factorization)

pr = mod(expand_factorization(factorization),prime)
println("Reconstructing: ", pr)
    \end{Verbatim}
\end{codebox}

Output (with the third line split so the output will fit on the document):
\begin{Verbatim}
    Will factor this polynomial (mod 17): 7x^5 + 9x^4 + 11x^2 + 9x + 1
    Here is the factorization: Tuple{Polynomial, Int64}[(x + 8, 1),
        (x^2 + x + 1, 1), (x^2 + 2x + 7, 1), (7, 1)]
    Reconstructing: 7x^5 + 9x^4 + 11x^2 + 9x + 1
\end{Verbatim}

\bigbreak

\section{Tests}
The provided tests produce the following output:
\begin{Verbatim}
    test_euclid_ints - PASSED
    test_ext_euclid_ints - PASSED
    prod_test_poly - PASSED
    prod_derivative_test_poly - PASSED
    ext_euclid_test_poly - PASSED
    division_test_poly - PASSED

    doing prime = 5 	 ..........
    doing prime = 17 	..........
    doing prime = 19 	..........
    factor_test_poly - PASSED
\end{Verbatim}

\bigbreak

\section{Task 1}
\subsection{Example Script 2}
The new example script \texttt{example\_script\_2.jl} explores the main
functionality of the codebase: basic arithmetic on polynomials, the extended
Euclidean algorithm, Euclidean division, and factorization. Most notably,
because the division and factorization algorithms require us to work in
$\mathbb{Z}_p[x]$ for prime $p$, examples were given using different coefficient
fields:

\begin{codebox}[example\_script\_2.jl]
    \begin{Verbatim}[numbers=left,xleftmargin=5mm]
# division
println("\nDivision")
f1 = rand(PolynomialSparse; degree = 4, mean_degree = 2.0, max_coeff = 5)
f2 = rand(PolynomialSparse; degree = 3, mean_degree = 1.5, max_coeff = 5)
f3 = rand(PolynomialSparse; degree = 2, mean_degree = 1.0, max_coeff = 5)
g1, g2 = f1 * f2 + f3, f2
@show g1
@show g2
println("Euclidean division for g1 / g2:")
primes = [7, 11, 13, 17, 19, 23, 29]
for p in primes
    dividend, remainder = (divide(g1, g2))(p)
    println("\tin Z/$p[x]:\tg1 = ($dividend)($g2) + $remainder  (mod $p)")
end

# factorization
println("\nFactorization in Z/p[x]")
println("Let f = $f1 * $f2")
f = f1 * f2
@show f
for p in primes[3:end]
    factorization = factor(f, p)
    println("\tin Z/$p[x]:\tf = $factorization")
    println("\tReconstruction:\t$(mod(expand_factorization(factorization), p))")
end
    \end{Verbatim}
\end{codebox}

Output:
\begin{Verbatim}
    Division
    g1 = 10x^7 + 4x^6 + 15x^5 + 16x^4 + 12x^3 + 5x^2 + 14x + 8
    g2 = 2x^3 + 3x + 2
    Euclidean division for g1 / g2:
        in Z/7[x]:	g1 = (5x^4 + 2x^3 + 4)(2x^3 + 3x + 2) + 5x^2 + 2x  (mod 7)
        in Z/11[x]:	g1 = (5x^4 + 2x^3 + 4)(2x^3 + 3x + 2) + 5x^2 + 2x  (mod 11)
        in Z/13[x]:	g1 = (5x^4 + 2x^3 + 4)(2x^3 + 3x + 2) + 5x^2 + 2x  (mod 13)
        in Z/17[x]:	g1 = (5x^4 + 2x^3 + 4)(2x^3 + 3x + 2) + 5x^2 + 2x  (mod 17)
        in Z/19[x]:	g1 = (5x^4 + 2x^3 + 4)(2x^3 + 3x + 2) + 5x^2 + 2x  (mod 19)
        in Z/23[x]:	g1 = (5x^4 + 2x^3 + 4)(2x^3 + 3x + 2) + 5x^2 + 2x  (mod 23)
        in Z/29[x]:	g1 = (5x^4 + 2x^3 + 4)(2x^3 + 3x + 2) + 5x^2 + 2x  (mod 29)

    Factorization in Z/p[x]
    Let f = 5x^4 + 2x^3 + 4 * 2x^3 + 3x + 2
    f = 10x^7 + 4x^6 + 15x^5 + 16x^4 + 12x^3 + 12x + 8
        in Z/13[x]:	f = (x + 10)(x + 7)(x^2 + 3x + 4)(x^3 + 9x^2 + 2x + 12)(10)
        Reconstruction:	10x^7 + 4x^6 + 2x^5 + 3x^4 + 12x^3 + 12x + 8
        in Z/17[x]:	f = (x + 4)(x + 2)^^2(x + 6)(x^3 + 10x + 1)(10)
        Reconstruction:	10x^7 + 4x^6 + 15x^5 + 16x^4 + 12x^3 + 12x + 8
        in Z/19[x]:	f = (x + 11)(x + 13)(x^2 + 3x + 13)(x^3 + 11x + 1)(10)
        Reconstruction:	10x^7 + 4x^6 + 15x^5 + 16x^4 + 12x^3 + 12x + 8
        in Z/23[x]:	f = (x + 4)(x^2 + 19x + 6)(x^4 + 5x^3 + 10)(10)
        Reconstruction:	10x^7 + 4x^6 + 15x^5 + 16x^4 + 12x^3 + 12x + 8
        in Z/29[x]:	f = (x + 18)(x^2 + 11x + 21)(x^4 + 12x^3 + 24)(10)
        Reconstruction:	10x^7 + 4x^6 + 15x^5 + 16x^4 + 12x^3 + 12x + 8
\end{Verbatim}

\bigbreak

\subsection{Pretty Printing}
The show methods in both \texttt{polynomial.jl} and \texttt{term.jl} were
modified to meet the pretty printing rules. A global option was added to
determine if terms in polynomials were printed in ascending or descending term
order (defaulting to descending):

\begin{codebox}[polynomial.jl]
    \begin{Verbatim}[numbers=left,xleftmargin=5mm]
"""
Based global variable for deciding the order in which polynomial terms are
printed
"""
global lowest_to_highest :: Bool = false
    \end{Verbatim}
\end{codebox}

The provided \texttt{show} method for polynomials was replaced with the
following:

\begin{codebox}[polynomial.jl]
    \begin{Verbatim}[numbers=left,xleftmargin=5mm]
function show(io::IO, p::Polynomial) 
    if iszero(p)
        print(io,"0")
    else
        is_first = true
        n = length(p.terms)
        term_list = lowest_to_highest ? p.terms : reverse(p.terms)
        for t in term_list
            if iszero(t)
                continue
            elseif is_first
                print(io, t.coeff < 0 ? "-" : "", t)
            else
                print(io, t.coeff < 0 ? " - " : " + ", t)
            end
            is_first = false
        end
    end
end
    \end{Verbatim}
\end{codebox}

First, observe that the \texttt{lowest\_to\_highest} flag is used on line 7 to
determine in which order to iterate over the list of terms. If the given
polynomial is the zero polynomial, then the output is \texttt{0}. Otherwise, the
\texttt{show} method above will simply skip those terms which are zero.
Printing terms with negative coefficient as \texttt{1 - x} instead of
\texttt{1 + -x} was implemented by changing the monomial show method to always
display the absolute value of the coefficient. Then on line 14 above, the
\texttt{show} method prints either a \texttt{+} or \texttt{-} sign in front of
the monomial as appropriate. \medbreak

The final consideration is how to print the first term in the monomial so that
there is not ``\texttt{ + }" or ``\texttt{ - }" with excessive surrounding
whitespace at the start of the \texttt{show} output. It is not necessarily the
case that the first term in the list of terms for the polynomial will be
non-zero, so we introduce on line 5 a flag \texttt{is\_first}, which will be set
until the first non-zero term has been printed. Then at the first term we need
only check if it has positive coefficient (and print nothing before the term),
or negative (in which case we print ``\texttt{-}" with no surrounding
whitespace). \medbreak

Consider now the implementation of the \texttt{show} method for monomials:

\begin{codebox}[term.jl]
    \begin{Verbatim}[numbers=left,xleftmargin=5mm]
function show(io::IO, t::Term)
    if t.degree == 0
        print(io, abs(t.coeff))
    elseif abs(t.coeff) == 1
        print(io, "x", t.degree == 1 ? "" : int_to_superscript(t.degree))
    else
        print(io, abs(t.coeff), "x",
            t.degree == 1 ? "" : int_to_superscript(t.degree))
    end
end
    \end{Verbatim}
\end{codebox}

We check for zero degree terms (and print the coefficient only) on lines 2-3. At
line 4-5 we check if a polynomial has non-zero degree and has a coefficient of
$\pm 1$, in which case we print \texttt{x} instead of \texttt{1x}. Furthermore,
on lines 5 and 7-8, we only print the degree of the monomial if it not 1.
\medbreak

Finally, unicode superscript printing was implemented using a function
\texttt{int\_to\_superscript}:

\begin{codebox}[general\_alg.jl]
    \begin{Verbatim}[numbers=left,xleftmargin=5mm]
function digit_to_superscript(n :: Int) :: Char
    # Literal for zero
    zero_code = 0x2070
    
    # cringe edge cases
    if n == 1
        return Char(0x00B9)
    elseif n == 2
        return Char(0x00B2)
    elseif n == 3
        return Char(0x00B3)
    else
        # based normal case
        return Char(zero_code + n)
    end
end

function int_to_superscript(k :: Int) :: String
    k == 0 ? "" : int_to_superscript(div(k, 10)) * digit_to_superscript(mod(k, 10))
end
    \end{Verbatim}
\end{codebox}

The function \texttt{digit\_to\_superscript} converts a single digit to a
superscript unicode character and is called in the recursively defined
\texttt{int\_to\_superscript} on line 18. Notice that the \texttt{*} operator on
line 19 is the string concatenation operator. Although converting the input
\texttt{k} into a string and then mapping each character to a superscript one
would have worked, this method is much more efficient as no memory is allocated
for an intermediate string representation of the input.

\bigbreak

\section{Task 2}
\subsection{\texttt{PolynomialSparse}}
The \texttt{PolynomialSparse} only stores \emph{non-zero} terms and is defined
below. We will discuss the \texttt{DictLinkedList} data structure in detail in
section \ref{dll}. We will explore the definition of the
\texttt{PolynomialSparse} type and look at the non-trivial operations on it
which are substantially different to those on the provided type.

\begin{codebox}[polynomial\_sparse.jl]
    \begin{Verbatim}[numbers=left,xleftmargin=5mm]
struct PolynomialSparse

    # DictLinkedList mapping degrees of terms to the term. A polynomial is the
    # zero polynomial if and only if DictLinkedList is empty
    terms :: DictLinkedList{Int, Term}
    
    #Inner constructor of 0 polynomial
    PolynomialSparse() = new(DictLinkedList{Int, Term}(isless))

    #Inner constructor of polynomial based on arbitrary list of terms
    function PolynomialSparse(vt::Vector{Term})
        terms = DictLinkedList{Int, Term}(isless)
        for t in vt
            if iszero(t)
                continue
            elseif contains(terms, t.degree)
                replace!(terms, t.degree, t)
            else
                insert!(terms, t.degree, t)
            end
        end
        new(terms)
    end

    PolynomialSparse(dll :: DictLinkedList{Int, Term}) = new(dll)
end
    \end{Verbatim}
\end{codebox}

Notice in particular that, because we only store non-zero terms inside a sparse
polynomial, the unique way to represent the zero polynomial is the one where the
\texttt{terms} field is empty. Addition was implemented using heap-like
operations on \texttt{PolynomialSparse.terms} to take advantage of the
underlying list being sorted.

\begin{codebox}[basic\_polynomial\_operations/polynomial\_addition.jl]
    \begin{Verbatim}[numbers=left,xleftmargin=5mm]
function +(p1 :: PolynomialSparse, p2 :: PolynomialSparse) :: PolynomialSparse
    p1_ = deepcopy(p1)
    p2_ = deepcopy(p2)
    p = PolynomialSparse()
    while !iszero(p1_) || !iszero(p2_)
        if (degree(p1_) == degree(p2_))
            t = pop!(p1_) + pop!(p2_)
            iszero(t) ? continue : push!(p, t)
        elseif degree(p1_) > degree(p2_)
            push!(p, pop!(p1_))
        else
            push!(p, pop!(p2_))
        end
    end
    return p
end
    \end{Verbatim}
\end{codebox}

\bigbreak

\subsection{Tests}
For the most part the tests for sparse polynomials are identical to those for
dense polynomials, but an additional test \texttt{pow\_mod\_poly\_sparse} was
added to test the efficiency sparse polynomial operations on sparse polynomials.
The assertion on lines 6-7 below checks that $\texttt{leading}(f^n) =
\texttt{leading}(f)^n \pmod{19}$:

\begin{codebox}[test/polynomial\_sparse\_test.jl]
    \begin{Verbatim}[numbers=left,xleftmargin=5mm]
function pow_mod_poly_sparse(;prime::Int = 19, N::Int = 30, seed::Int = 0)
    Random.seed!(seed)
    print("pow_mod_poly_sparse\t")
    for k in 1:N
        f = rand(PolynomialSparse; prob_term = 0.01, mean_degree = Float64(120))
        @assert (leading(pow_mod(f, k, prime)).coeff
            == pow_mod(leading(f).coeff, k, prime))
        print(".")
    end
    println("\tPASSED")
end
    \end{Verbatim}
\end{codebox}

\bigbreak

\subsection{\texttt{DictLinkedList} Data Structure} \label{dll}
The data structure \texttt{DictLinkedList\string{K, V\string}} is a sorted
linked list with values of type \texttt V along with a dictionary mapping some
key type \texttt K into the nodes of the linked list so that we can quickly
lookup values inside the linked list without having to traverse it. To make
the type polymorphic, we simply add a field in the struct containing a
comparator \texttt{comp}.

\begin{codebox}[dict\_linked\_list.jl]
    \begin{Verbatim}[numbers=left,xleftmargin=5mm]
mutable struct DictLinkedList{K, V}
    # Sorted linked list
    list :: MutableLinkedList{V}
    # Dictionary with with values pointing nodes in the linked list
    dict :: Dict{K, DataStructures.ListNode{V}}
    # total order on V
    comp :: Function

    DictLinkedList{K, V}(comp) where {K, V} = new(
        MutableLinkedList{V}(),
        Dict{K, DataStructures.ListNode{V}}(),
        comp)
end
    \end{Verbatim}
\end{codebox}

The \texttt{iteration} interface is implemented by simply iterating over the
underlying linked list (in order). Observe that on line 4 we compare pointers
for equality to improve speed without sacrificing correctness:

\begin{codebox}[dict\_linked\_list.jl]
    \begin{Verbatim}[numbers=left,xleftmargin=5mm]
function Base.iterate(
        dll :: DictLinkedList{K, V},
        state = dll.list.node) where {K, V}
    root_node = dll.list.node
    state.next === root_node ? nothing : (state.next.data, state.next)
end
    \end{Verbatim}
\end{codebox}

We may insert elements into the linked list
using \texttt{insert!}, which takes a key and value and inserts the value into
the underlying list (such that order is preserved) and maps the key to a pointer
to the newly created list node in the underlying dictionary.

\begin{codebox}[dict\_linked\_list.jl]
    \begin{Verbatim}[numbers=left,xleftmargin=5mm]
function insert!(dll :: DictLinkedList{K, V}, key :: K, value :: V) where {K, V}
    # check the key does not already exist in the dictionary
    haskey(dll.dict, key) && error("Duplicate key")

    # Pointer to the element immediately before where value should be inserted
    elem_before = dll.list.node
    if dll.comp(elem_before.prev.data, value)
        # can insert at the end of the list
        elem_before = elem_before.prev
    else
        next = iterate(dll)
        while next !== nothing
            (x, current) = next
            if dll.comp(x, value)
                elem_before = current
                next = iterate(dll, current)
            else
                break
            end
        end
    end
    # insert the value here
    new_node = DataStructures.ListNode{V}(value)
    new_node.prev = elem_before
    new_node.next = elem_before.next
    elem_before.next.prev = new_node
    elem_before.next = new_node
    dll.list.len += 1

    # add an entry to the dictionary
    dll.dict[key] = new_node
    return nothing
end
    \end{Verbatim}
\end{codebox}

There is also a method to remove a key from the dictionary and the value pointed
to by the key from the list:

\begin{codebox}[dict\_linked\_list.jl]
    \begin{Verbatim}[numbers=left,xleftmargin=5mm]
function remove!(dll :: DictLinkedList{K, V}, key :: K) :: Nothing where {K, V}
    !haskey(dll.dict, key) && error("Key does not exist")
    node = dll.dict[key]
    delete!(dll.dict, key)
    node.prev.next = node.next
    node.next.prev = node.prev
    dll.list.len -= 1
    return nothing
end
    \end{Verbatim}
\end{codebox}

Several other methods (including \texttt{filter!}, \texttt{lookup},
\texttt{map}, \texttt{replace!} and \texttt{show}) were implemented, none of
which are particularly exciting.

\bigbreak

\subsection{Discussion}

Having written the tests for sparse polynomials to be identical to those
provided for dense polynomials (and having added a test
\texttt{pow\_mod\_poly\_dense}, we may easily compare the performance of each
data type using the \texttt{@time} macro. For the sake of conciseness, all
output except running time and memory used from \texttt{@time} has been manually
removed from the output:

\begin{Verbatim}
    ######################################
    # Dense polynomial tests #
    ######################################
    prod_test_poly - PASSED
     15.369265 seconds (allocations: 51.691 GiB)
    prod_derivative_test_poly - PASSED
      0.003282 seconds (allocations: 10.690 MiB)
    ext_euclid_test_poly - PASSED
      0.219019 seconds (allocations: 491.821 MiB)
    division_test_poly - PASSED
      0.870298 seconds (allocations: 2.168 GiB)

    doing prime = 5 	..........
    doing prime = 17 	..........
    doing prime = 19 	..........
    factor_test_poly - PASSED
      6.233989 seconds (allocations: 26.530 GiB)
    pow_mod_poly	..............................	PASSED
    103.016862 seconds (allocations: 839.748 GiB)


    ######################################
    # Sparse polynomial tests #
    ######################################
    prod_test_poly_sparse - PASSED
     96.805889 seconds (allocations: 17.225 GiB)
    prod_derivative_test_poly_sparse - PASSED
      0.050551 seconds (allocations: 9.714 MiB)
    ext_euclid_test_poly_sparse - PASSED
      4.398652 seconds (allocations: 717.324 MiB)
    division_test_poly_sparse - PASSED
     13.927326 seconds (allocations: 2.087 GiB)

    doing prime = 5 	..........
    doing prime = 17 	..........
    doing prime = 19 	..........
    factor_test_poly_sparse - PASSED
     19.405532 seconds (allocations: 3.475 GiB)
    pow_mod_poly_sparse	..............................	PASSED
     23.076168 seconds (allocations: 4.589 GiB)
\end{Verbatim}

All of the above tests except \texttt{pow\_mod\_poly} and
\texttt{pow\_mod\_poly\_sparse} use operations on dense polynomials, and in
each of these it is clear that, in all but \texttt{ext\_euclid\_test\_poly},
polynomial sparse is slower but uses less memory. However, in the test
\texttt{pow\_mod\_poly} which uses sparse polynomials, where
\texttt{PolynomialSparse} is both faster and uses less than $0.01\%$ of the
memory of \texttt{PolynomialDense}.

\bigbreak

\section{Task 3}
\subsection{\texttt{PolynomialSparse128}}
The new type \texttt{PolynomialSparse} was implemented by making existing types
\texttt{Term}, and \texttt{PolynomialSparse} polymorphic over a coefficient type
\texttt{I <: Integer}. For convenience, we define an abstract type
\texttt{Polynomial} and write:

\begin{codebox}[term.jl]
    \begin{Verbatim}[numbers=left,xleftmargin=5mm]
struct Term{I}
    coeff :: I
    degree :: Int

    function Term{I}(coeff::Int, degree::I) where I <: Integer
        ...
    end
end
    \end{Verbatim}
\end{codebox}

\begin{codebox}[polynomial\_dense.jl]
    \begin{Verbatim}[numbers=left,xleftmargin=5mm]
struct PolynomialDense <: Polynomial
    terms::Vector{Term{Int}}   
    PolynomialDense() = new([zero(Term{Int})])

    function PolynomialDense(vt::Vector{Term{Int}})
        ...
    end
end
    \end{Verbatim}
\end{codebox}

\begin{codebox}[polynomial\_dense.jl]
    \begin{Verbatim}[numbers=left,xleftmargin=5mm]
struct PolynomialSparse_{I} <: Polynomial
    terms :: DictLinkedList{Int, Term{I}}

    PolynomialSparse_{I}() where I <: Integer = new(
        DictLinkedList{Int, Term{I}}(isless))

    function PolynomialSparse_{I}(vt::Vector{Term{I}}) where I <: Integer
        ...
    end

    PolynomialSparse_{I}(
        dll :: DictLinkedList{Int, Term{I}}) where I <: Integer = new(dll)
end
    \end{Verbatim}
\end{codebox}

We furthermore define type aliases
\begin{Verbatim}
    const PolynomialSparse = PolynomialSparse_{Int}
    const PolynomialSparse128 = PolynomialSparse_{Int128}
\end{Verbatim}

\bigbreak

\subsection{Tests}
The tests for \texttt{PolynomialSparse128} are identical to those for
\texttt{PolynomialSparse} and \texttt{PolynomialDense}, but with an added test
which provides an example of an operation that would overflow on a 64-bit
integer, but not on 128-bit integer:

\begin{codebox}[test/polynomial\_sparse128\_test.jl]
    \begin{Verbatim}[numbers=left,xleftmargin=5mm]
function overflow_poly_sparse_128()
    x = x_poly(PolynomialSparse128)
    f = Int128(2^50) * x
    @assert leading(f^2).coeff == (leading(f).coeff)^2
end
    \end{Verbatim}
\end{codebox}

\bigbreak

\subsection{Runtime Performance}
Consider the following output from running the tests for both
\texttt{PolynomialSparse} and \texttt{PolynomialSparse128} with the \texttt{@time}
macro (all output from \texttt{@time} except the running time has been manually
removed):

\begin{Verbatim}
    ######################################
    # Sparse polynomial tests #
    ######################################
    prod_test_poly_sparse - PASSED
     75.498524 seconds
    prod_derivative_test_poly_sparse - PASSED
      0.040331 seconds
    ext_euclid_test_poly_sparse - PASSED
      3.439180 seconds
    division_test_poly_sparse - PASSED
     10.786113 seconds

    doing prime = 5 	..........
    doing prime = 17 	..........
    doing prime = 19 	..........
    factor_test_poly_sparse - PASSED
     15.101744 seconds
    pow_mod_poly_sparse	..............................	PASSED
     17.842930 seconds



    ######################################
    # 128-bit Sparse polynomial tests #
    ######################################
    prod_test_poly_sparse_128 - PASSED
     75.670094 seconds
    prod_derivative_test_poly_sparse_128 - PASSED
      0.039650 seconds
    ext_euclid_test_poly_sparse_128 - PASSED
      3.547918 seconds
    division_test_poly_sparse_128 - PASSED
     10.966848 seconds

    doing prime = 5 	..........
    doing prime = 17 	..........
    doing prime = 19 	..........
    factor_test_poly_sparse_128 - PASSED
     12.451121 seconds
    pow_mod_poly_sparse_128	..............................	PASSED
     17.090768 seconds
\end{Verbatim}
It is clear that there is no significant runtime cost associated with using
128-bit coefficients, which is reasonable because each term with a 128-bit
coefficent is only 1 word larger than one using a 64-bit coefficient.

\bigbreak

\section{Task 4}
\subsection{\texttt{PolynomialModP} Implementation}
Because the \texttt{Term\string{I\string}} type is already polymorphic over the
underlying coefficient type, we can implement almost \emph{all} of the novel
functionality of \texttt{PolynomialModP} by creating a type
\texttt{ResidueInt <: Integer} representing a residue class of the integers
modulo some prime.

\begin{codebox}[src/residue\_int.jl]
    \begin{Verbatim}[numbers=left,xleftmargin=5mm]
struct ResidueInt <: Integer
    # Prime used to construct the field of residue classes
    prime :: Int128
    # Value mod prime
    value :: Int128

    function ResidueInt(value :: I, p :: J) where {I <: Integer, J <: Integer}
        return new(Int128(p), Int128(mod(value, p)))
    end
end

    \end{Verbatim}
\end{codebox}

Notice in particular that both the prime and the value are stored in the
\texttt{Int128} type so that we can work in the integers modulo a large prime
(this becomes relevant in section \ref{crt}). We also define some basic
arithmetic operations:

\begin{codebox}[src/residue\_int.jl]
    \begin{Verbatim}[numbers=left,xleftmargin=5mm]
fmap(f :: Function, x :: ResidueInt) = ResidueInt(f(x.value), x.prime)

function +(x :: ResidueInt, y :: ResidueInt)
    @assert x.prime == y.prime
    return ResidueInt(x.value + y.value, x.prime)
end

function -(x :: ResidueInt, y :: ResidueInt)
    @assert x.prime == y.prime
    return ResidueInt(x.value - y.value, x.prime)
end

function *(x :: ResidueInt, y :: ResidueInt)
    @assert x.prime == y.prime
    return ResidueInt(x.value * y.value, x.prime)
end

function inverse(x :: ResidueInt)
    @assert !iszero(x)
    g, t, s = ext_euclid_alg(x.value, x.prime)
    @assert Base.abs(g) == 1
    return ResidueInt(t, x.prime)
end

function √∑(x :: ResidueInt, y :: ResidueInt)
    @assert x.prime == y.prime
    return x * inverse(y)
end

-(x :: ResidueInt) = fmap(-, x)

-(x :: ResidueInt, y :: ResidueInt) = x + (-y)
    \end{Verbatim}
\end{codebox}

We define the following operations using both integers and the
\texttt{ResidueInt} type:

\begin{codebox}[src/residue\_int.jl]
    \begin{Verbatim}[numbers=left,xleftmargin=5mm]
+(x :: ResidueInt, y :: I) where I <: Integer = x + ResidueInt(y, x.prime)
+(y :: I, x :: ResidueInt) where I <: Integer = x + ResidueInt(y, x.prime)

*(x :: ResidueInt, y :: I) where I <: Integer = x * ResidueInt(y, x.prime)
*(y :: I, x :: ResidueInt) where I <: Integer = x * ResidueInt(y, x.prime)

-(x :: ResidueInt, y :: I) where I <: Integer = x - ResidueInt(y, x.prime)
-(y :: I, x :: ResidueInt) where I <: Integer = ResidueInt(y, x.prime) - x

√∑(x :: ResidueInt, y :: I) where I <: Integer = x √∑ ResidueInt(y, x.prime)

function ^(x :: ResidueInt, y :: I) where I <: Integer
    iszero(x) && return deepcopy(x)
    y < 0 && return inverse(x) ^ (-y)
    ret = one(ResidueInt, x.prime)
    d = y
    while d > 0
        ret *= x
        d -= 1
        ret == 1 && return x^(mod(y, (y - d))) # x^(y - d) = 1
    end
    return ret
end
    \end{Verbatim}
\end{codebox}

The implementation of \texttt{PolynomialModP} is identical to that of
\texttt{PolynomialSparse}, but we need to create a distinct struct so that we
can store the underlying prime.

\begin{codebox}[src/polynomial\_mod\_p.jl]
    \begin{Verbatim}[numbers=left,xleftmargin=5mm]
struct PolynomialModP <: Polynomial
    terms :: DictLinkedList{Int, Term{ResidueInt}}
    prime :: Int128
    
    PolynomialModP(prime :: I) where I <: Integer = new(
        DictLinkedList{Int, Term{ResidueInt}}(isless), Int128(prime))

    function PolynomialModP(vt::Vector{Term{ResidueInt}},
            prime :: I) where I <: Integer
        ...
    end

    function PolynomialModP(vt::Vector{Term{I}},
            prime :: J) where {I <: Integer, J <: Integer}
        ...
    end

    PolynomialModP(dll :: DictLinkedList{Int, Term{ResidueInt}},
        prime :: I) where I <: Integer = new(dll, Int128(prime))
end
    \end{Verbatim}
\end{codebox}

Functions like polynomial division, gcd, and factorization which had required
a prime to be supplied along with a polynomial in $\mathbb{Z}[x]$ make more
sense to call when working in $\mathbb{Z}_p[x]$. All we need to do to implement
these functions for \texttt{PolynomialModP} is remove the calls to \texttt{mod}
and use the underlying prime of \texttt{PolynomialModP} instead of an argument
to a function (where  it is applicable). For example, consider the
implementations of division for \texttt{PolynomialModP} and
\texttt{PolynomialSparse\_\string{I\string}}:

\begin{codebox}[src/basic\_polynomial\_operations/polynomial\_division.jl]
    \begin{Verbatim}[numbers=left,xleftmargin=5mm]
function divide(num :: PolynomialModP, den :: PolynomialModP)
    @assert num.prime == den.prime
    f = deepcopy(num)
    g = den
    iszero(g) && throw(DivideError())
    q = zero(num)
    prev_degree = degree(f)
    while degree(f) >= degree(g) 
        h = PolynomialModP(leading(f) √∑ leading(g))
        f = f - h*g
        q += h
        prev_degree == degree(f) && break
        prev_degree = degree(f)
    end
    @assert iszero(num  - (q*g + f))
    return q, f
end

function divide(num :: PolynomialSparse_{I},
        den :: PolynomialSparse_{I}) where I <: Integer
    function division_function(prime::J) where J <: Integer
        p = I(prime)
        f, g = mod(num,p), mod(den,p)
        degree(f) < degree(num) && return nothing 
        iszero(g) && throw(DivideError())
        q = PolynomialSparse_{I}()
        prev_degree = degree(f)
        while degree(f) >= degree(g) 
            h = PolynomialSparse_{I}((leading(f) √∑ leading(g))(p))  #syzergy 
            f = mod((f - h*g), p)
            q = mod((q + h), p)
            prev_degree == degree(f) && break
            prev_degree = degree(f)
        end
        @assert iszero( mod((num  - (q*g + f)),p))
        return q, f
    end
    return division_function
end
    \end{Verbatim}
\end{codebox}

\bigbreak

\subsection{Tests}
The tests are identical to those for \texttt{PolynomialSparse} and may be found
in \texttt{test/polynomia\_mod\_p\_test.jl}

\bigbreak

\subsection{\texttt{pow\_mod}}

\bigbreak

\section{Task 5} \label{crt}
\subsection{CRT Mutliplication in \texttt{PolynomialSparse128}}

\bigbreak

\subsection{Tests}

\bigbreak

\subsection{Benchmarks}
CRT multiplication is designed to speed up multiplications using dynamically
sized integers; that is, integers too big to fit into one or two words. This is
becuase we can do the fast in-built operations on integers that can fit in the
CPU and reconstruct the polynomial with dynamically sized integers once at the
end. Doing multiplication using the \emph{Chinese Remainder Theorem} is
\emph{never} more efficient than naive polynomial multiplication on
\texttt{Int128} or \texttt{Int64}, so we expect the benchmark to find that CRT
multiplication is far slower than our naive implementation. The benchmark runs
the following:

\begin{codebox}[test/benchmark.jl]
    \begin{Verbatim}[numbers=left,xleftmargin=5mm]
function chinese_remainder_multiplication(;N :: Int = 10^4, seed :: Int = 0)
    println("Old Multiplication")
    @time benchmark(*, N, seed)
    println("CRT Multiplication")
    @time benchmark(multiply, N, seed)
end

function benchmark(fn, N :: Int, seed :: Int)
    Random.seed!(seed)
    for _ in 1:N
        f = rand(PolynomialSparse128)
        g = rand(PolynomialSparse128)
        @assert f * g == fn(f, g)
    end
end

chinese_remainder_multiplication()
    \end{Verbatim}
\end{codebox}

The above produces the following output, confirming what we expected:

\begin{Verbatim}
    Old Multiplication
      2.551337 seconds (10.79 M allocations: 622.081 MiB)
    CRT Multiplication
     59.006724 seconds (281.37 M allocations: 19.979 GiB)
\end{Verbatim}

\end{document}
